extern crate winapi;

use std::env;
use std::fs;
use std::io::{self, Read, Write};
use std::net::TcpStream;
use std::path::PathBuf;
use std::ptr;
use std::thread;
use std::time::Duration;
use winapi::um::processthreadsapi::{GetCurrentProcess, OpenProcessToken};
use winapi::um::securitybaseapi::GetTokenInformation;
use winapi::um::winnt::{TokenElevation, HANDLE, TOKEN_ELEVATION, TOKEN_QUERY};
fn has_admin_rights() -> bool {
    unsafe {
        let mut handle: HANDLE = ptr::null_mut();
        if OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &mut handle) == 0 {
            return false;
        }

        let mut elevation: TOKEN_ELEVATION = std::mem::zeroed();
        let mut size = std::mem::size_of::<TOKEN_ELEVATION>() as u32;

        let result = GetTokenInformation(
            handle,
            TokenElevation,
            &mut elevation as *mut _ as *mut _,
            size,
            &mut size,
        );

        if result == 0 {
            return false;
        }

        elevation.TokenIsElevated != 0
    }
}

fn make_network_connection(address: &str) {
    match TcpStream::connect(address) {
        Ok(_) => println!("Successfully connected to {}", address),
        Err(e) => println!("Failed to connect: {}", e),
    }
}

fn main() {
    if has_admin_rights() {
        println!("Already an admin. Making network connection...");
        make_network_connection("127.0.0.1:8080"); // Replace with your target address and port
    } else {
        let exe_path = env::current_exe().expect("Failed to get current executable path");
        let mut new_path = PathBuf::from("C:\\Path\\To\\Copy\\To");
        new_path.push("copied_program.exe");

        //fs::copy(&exe_path, &new_path).expect("Failed to copy executable");

        println!("Executable copied to {:?}", new_path);
        make_network_connection("127.0.0.1:4444");
    }
}
